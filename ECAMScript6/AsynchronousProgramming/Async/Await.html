<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Async/Await</title>
</head>
<body>
<script>
<!--  Async函数和Generator函数差不多，只是将函数里面的* 换成了async,将yield换成await-->
  /*async函数返回一个promise对象，可以使用then方法添加回调函数。
  当函数执行时，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句
  * */
async function gen(x){
  var y = await x + 2;
  var z = await y + 2;
  return z;
}
gen(1).then(
        result => console.log(result)
        error => console.log(error)
)
/*await关键词必须出现在saync函数中，一般来讲await命令后面是一个promise对象，
返回该对象的结果，如果不是promise对象，则直接返回对应的值
*
* */
async function fn1(){
  console.log('2')
  return 'b'
}
async function fn2(){
  const result = await fn1();
  console.log(result)
}
//   上面实例代码等于下面的
function fn1(){
  return new Promise((resolve , reject) => {
    console.log('a')
    return 'b'
  })
}
function fn2(){
  return new Promise((resolve , reject) => {
    fn1().then(data => {
      const result = data;
      console.log(result)
      resolve();
    })
  })
}
fn2()
/* 任何一个await语句后面的promise对选哪个变成reject状态，整个async函数
都会出现中断。如果希望前一个异步操作失败，则不要中断后面的异步操作，这时可以将swait放在try....catch结构里面
*/
async function fn3() {
    try{
      await Promise.reject('error')
    }catch (e) {}
        return await Promise.resolve('hello')
    }
fn().then(v => {
console.log(v)
})




</script>
</body>
</html>