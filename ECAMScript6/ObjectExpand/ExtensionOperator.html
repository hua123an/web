<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ExtensionOprator</title>
<!--  对象的扩展运算符-->
</head>
<body>
<script>
<!--  对象的扩展运算符用于取出参数对象的所有可遍历属性，然后复制到当前对象之中-->
let z = {a : 3 , b : 4};
let n = {...z};
console.log(n)
// 由于数组是特殊的u底下那个，所以对象的扩展运算符也可以用于数组
let foo = {...['a' , 'b' , 'c']}
console.log(foo)
// 如果扩展运算符后面是一个空对象，则没有任何效果
let a = {...{}, b : 1}
console.log(a);        //此时只会输出{b : 1}
//如果扩展运算符后面不是对象，则会自动转化为对象
let b = {name : 'zhangsan',age : 17}
let a = {...Object(b)}
console.log(a)
// 当出现扩展运算符后面是整数时，会自动转化为数值的包装对象Number(num)，由于该对象自身没有属性，则会返回空对象。
// 但是，如果扩展运算符后面是字符串时，它会将字符串对象转换成一个类似数组对象，因此返回的不是空对象
let a = {...'hello'};
console.log(a)
// 对象的扩展运算符等同于使用Object.assign()方法
let aClone = {...a};
// 等同于
let aClone = Object.assign({} , a)
// 上卖弄例子只是复制了对象实例的属性，如果想完整复制一个对象原型属性，则要用下面方法:
// 方法一(继承)
const clone1 = {
  _proto_ : Object.getPrototypeOf(obj),
  ...obj
}
// 方法二
const clone2  = Object.assign(
        Object.create(Object.getPrototypeOf(obj)),
        console.log(obj)
)
// 方法三
const clone3 = Object.create(
        Object.getPrototypeOf(obj),
        Object.getOwnPropertyDescriptors(obj)
)
// 扩展运算符可以用于合并多个数组
let ab = {...a , ...b}
// 等同于
let ab = Object.assign({} , a , b)
</script>
</body>
</html>